name: ImmortalWrt Builder

on:
  workflow_dispatch:
    inputs:
      upload_release:
        description: 'Upload firmware artifacts and publish GitHub Release'
        type: boolean
        required: false
        default: true
      debug_build:
        description: 'Debug build: single-thread + verbose logs'
        type: boolean
        required: false
        default: false
      jobs:
        description: 'Parallel jobs: auto=nproc, or fixed number'
        type: choice
        required: false
        default: auto
        options:
          - auto
          - "1"
          - "2"
          - "4"
          - "8"
          - "16"
      model:
        description: 'Select model to build'
        type: choice
        required: false
        default: all
        options:
          - all
          - cr6606
          - tr3000
      immortalwrt_ref:
        description: 'ImmortalWrt git ref (branch, tag, or commit SHA)'
        type: string
        required: false
        default: ''

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-${{ github.event.inputs.model || 'all' }}-${{ (github.event.inputs.immortalwrt_ref && github.event.inputs.immortalwrt_ref) || (vars.IMMORTALWRT_REF && vars.IMMORTALWRT_REF) || 'default' }}
  cancel-in-progress: true

permissions:
  contents: read

env:
  IMMORTALWRT_REF: ${{ github.event.inputs.immortalwrt_ref || vars.IMMORTALWRT_REF }}
  UPLOAD_RELEASE: ${{ github.event.inputs.upload_release || 'true' }}
  DEBUG_BUILD: ${{ github.event.inputs.debug_build || 'false' }}
  JOBS_INPUT: ${{ github.event.inputs.jobs || 'auto' }}
  CCACHE_MAX_SIZE: 4G
  # Notification settings
  BARK_SUCCESS_SOUND: "birdsong"
  BARK_FAILURE_SOUND: "calypso"
  BARK_ICON: "https://firmware-selector.immortalwrt.org/favicon.ico"
  BARK_GROUP: "ImmortalWrt"

jobs:
  build:
    name: Build (${{ matrix.model }})
    permissions:
      contents: write
      actions: write
    runs-on: ubuntu-latest
    container: ghcr.io/coachpo/immortalwrt-build-env:latest
    strategy:
      fail-fast: false
      matrix:
        model: ${{ fromJSON((github.event.inputs.model == '' || github.event.inputs.model == 'all') && '["cr6606","tr3000"]' || format('["{0}"]', github.event.inputs.model)) }}

    steps:
    - name: Checkout repository (with submodules)
      uses: actions/checkout@v4
      with:
        submodules: recursive
        fetch-depth: 1

    - name: Set ImmortalWrt submodule to requested ref
      if: ${{ env.IMMORTALWRT_REF != '' }}
      run: |
        set -e
        echo "Switching submodule 'immortalwrt' to ref: ${IMMORTALWRT_REF}"
        git -C immortalwrt fetch --all --tags --prune
        # Try ref as is; if not found, try origin/REF for branches
        if git -C immortalwrt rev-parse --verify --quiet "${IMMORTALWRT_REF}^{commit}"; then
          TARGET_REF="${IMMORTALWRT_REF}"
        elif git -C immortalwrt rev-parse --verify --quiet "origin/${IMMORTALWRT_REF}^{commit}"; then
          TARGET_REF="origin/${IMMORTALWRT_REF}"
        else
          echo "Ref '${IMMORTALWRT_REF}' not found in submodule. Available heads and tags:" >&2
          git -C immortalwrt show-ref --heads --tags | sed 's/^/  /' >&2 || true
          exit 1
        fi
        git -C immortalwrt checkout --recurse-submodules --detach "${TARGET_REF}"
        git -C immortalwrt submodule update --init --recursive --depth=1
        
    - name: Prepare ccache dir
      run: mkdir -p immortalwrt/.ccache

    - name: Restore ccache cache (per model/ref)
      uses: actions/cache@v4
      with:
        path: immortalwrt/.ccache
        key: ${{ runner.os }}-ccache-${{ matrix.model }}-${{ env.IMMORTALWRT_REF }}
        restore-keys: |
          ${{ runner.os }}-ccache-${{ matrix.model }}-
          ${{ runner.os }}-ccache-

    - name: Restore ImmortalWrt downloads cache (per model/ref)
      uses: actions/cache@v4
      with:
        path: immortalwrt/dl
        key: ${{ runner.os }}-dl-${{ matrix.model }}-${{ env.IMMORTALWRT_REF }}
        restore-keys: |
          ${{ runner.os }}-dl-${{ matrix.model }}-
          ${{ runner.os }}-dl-

    - name: Setup ccache
      run: |
        CCACHE_DIR=immortalwrt/.ccache ccache -M ${CCACHE_MAX_SIZE}

    - name: Restore feeds cache (per ref + feeds.conf)
      uses: actions/cache@v4
      with:
        path: immortalwrt/feeds
        key: ${{ runner.os }}-feeds-${{ hashFiles('immortalwrt/feeds.conf.default') }}-${{ env.IMMORTALWRT_REF }}
        restore-keys: |
          ${{ runner.os }}-feeds-

    - name: Update feeds
      run: |
        cd immortalwrt
        ./scripts/feeds update -a

    - name: Install feeds
      run: |
        cd immortalwrt
        ./scripts/feeds install -a

    - name: Prepare model config
      run: |
        cp "${{ matrix.model }}/seed.config" immortalwrt/.config

    - name: Compute seed hash (for build caches)
      id: seed
      run: |
        HASH=$(sha256sum "${{ matrix.model }}/seed.config" | cut -d ' ' -f1)
        echo "SEED_HASH=$HASH" >> $GITHUB_ENV
        echo "seed_hash=$HASH" >> $GITHUB_OUTPUT

    - name: "Restore repo cache (release asset: zip)"
      id: restore_repo_cache
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      shell: bash
      run: |
        set -e
        set -o pipefail
        HIT="false"
        CACHE_TAG="cache-${{ matrix.model }}-${IMMORTALWRT_REF:-unknown}-${{ steps.seed.outputs.seed_hash }}"
        echo "Attempting to restore cache: tag=${CACHE_TAG} (zip)"
        URL_ZIP="https://github.com/${GITHUB_REPOSITORY}/releases/download/${CACHE_TAG}/repo-cache.zip"
        if curl -fL -H "Authorization: Bearer ${GITHUB_TOKEN}" -o repo-cache.zip "${URL_ZIP}"; then
          echo "Downloaded zip cache; extracting..."
          if command -v unzip >/dev/null 2>&1; then
            unzip -o -q repo-cache.zip || true
          elif command -v bsdtar >/dev/null 2>&1; then
            bsdtar -xf repo-cache.zip || true
          elif command -v python3 >/dev/null 2>&1; then
            python3 -c "import zipfile,sys; zipfile.ZipFile(sys.argv[1]).extractall('.')" repo-cache.zip || true
          else
            echo "No unzip utility available; skipping zip extraction." >&2
          fi
          rm -f repo-cache.zip || true
          # If extracted zip contains the known top-level artifact folder, move its immortalwrt/* content into place
          EXPECTED_ROOT="repo-cache-dirs-${{ matrix.model }}-${IMMORTALWRT_REF:-unknown}-${{ steps.seed.outputs.seed_hash }}"
          if [ -d "${EXPECTED_ROOT}" ]; then
            ROOT_DIR_CAND="${EXPECTED_ROOT}"
          else
            ROOT_DIR_CAND=$(find . -maxdepth 1 -mindepth 1 -type d -name "repo-cache-dirs-*" | head -n1 || true)
          fi
          if [ -n "${ROOT_DIR_CAND}" ] && [ -d "${ROOT_DIR_CAND}/immortalwrt" ]; then
            echo "Relocating restored cache directories from ${ROOT_DIR_CAND} into workspace..."
            mkdir -p immortalwrt
            for p in .ccache dl build_dir/host staging_dir/host; do
              if [ -d "${ROOT_DIR_CAND}/immortalwrt/${p}" ]; then
                mkdir -p "immortalwrt/${p}"
                rsync -a "${ROOT_DIR_CAND}/immortalwrt/${p}/" "immortalwrt/${p}/" || true
              fi
            done
            for m in "${ROOT_DIR_CAND}"/immortalwrt/build_dir/toolchain-*; do
              [ -d "${m}" ] || continue
              base=$(basename "${m}")
              mkdir -p "immortalwrt/build_dir/${base}"
              rsync -a "${m}/" "immortalwrt/build_dir/${base}/" || true
            done
            for m in "${ROOT_DIR_CAND}"/immortalwrt/staging_dir/toolchain-*; do
              [ -d "${m}" ] || continue
              base=$(basename "${m}")
              mkdir -p "immortalwrt/staging_dir/${base}"
              rsync -a "${m}/" "immortalwrt/staging_dir/${base}/" || true
            done
            rm -rf "${ROOT_DIR_CAND}" || true
          fi
          echo "Cache restored from ${CACHE_TAG} (zip)."
          HIT="true"
        else
          echo "No seed-specific cache found for ${CACHE_TAG}. Trying generic fallback..."
          GENERIC_TAG="cache-${{ matrix.model }}-${IMMORTALWRT_REF:-unknown}"
          URL_ZIP_GEN="https://github.com/${GITHUB_REPOSITORY}/releases/download/${GENERIC_TAG}/repo-cache.zip"
          if curl -fL -H "Authorization: Bearer ${GITHUB_TOKEN}" -o repo-cache.zip "${URL_ZIP_GEN}"; then
            echo "Downloaded generic zip cache; extracting..."
            if command -v unzip >/dev/null 2>&1; then
              unzip -o -q repo-cache.zip || true
            elif command -v bsdtar >/dev/null 2>&1; then
              bsdtar -xf repo-cache.zip || true
            elif command -v python3 >/dev/null 2>&1; then
              python3 -c "import zipfile,sys; zipfile.ZipFile(sys.argv[1]).extractall('.')" repo-cache.zip || true
            else
              echo "No unzip utility available; skipping zip extraction." >&2
            fi
            rm -f repo-cache.zip || true
            EXPECTED_ROOT="repo-cache-dirs-${{ matrix.model }}-${IMMORTALWRT_REF:-unknown}-${{ steps.seed.outputs.seed_hash }}"
            if [ -d "${EXPECTED_ROOT}" ]; then
              ROOT_DIR_CAND="${EXPECTED_ROOT}"
            else
              ROOT_DIR_CAND=$(find . -maxdepth 1 -mindepth 1 -type d -name "repo-cache-dirs-*" | head -n1 || true)
            fi
            if [ -n "${ROOT_DIR_CAND}" ] && [ -d "${ROOT_DIR_CAND}/immortalwrt" ]; then
              echo "Relocating restored cache directories from ${ROOT_DIR_CAND} into workspace..."
              mkdir -p immortalwrt
              for p in .ccache dl build_dir/host staging_dir/host; do
                if [ -d "${ROOT_DIR_CAND}/immortalwrt/${p}" ]; then
                  mkdir -p "immortalwrt/${p}"
                  rsync -a "${ROOT_DIR_CAND}/immortalwrt/${p}/" "immortalwrt/${p}/" || true
                fi
              done
              for m in "${ROOT_DIR_CAND}"/immortalwrt/build_dir/toolchain-*; do
                [ -d "${m}" ] || continue
                base=$(basename "${m}")
                mkdir -p "immortalwrt/build_dir/${base}"
                rsync -a "${m}/" "immortalwrt/build_dir/${base}/" || true
              done
              for m in "${ROOT_DIR_CAND}"/immortalwrt/staging_dir/toolchain-*; do
                [ -d "${m}" ] || continue
                base=$(basename "${m}")
                mkdir -p "immortalwrt/staging_dir/${base}"
                rsync -a "${m}/" "immortalwrt/staging_dir/${base}/" || true
              done
              rm -rf "${ROOT_DIR_CAND}" || true
            fi
            echo "Cache restored from generic tag ${GENERIC_TAG} (zip)."
            HIT="true"
          else
            echo "No generic cache found for ${GENERIC_TAG}. Proceeding with cold build."
          fi
        fi
        echo "hit=${HIT}" >> $GITHUB_OUTPUT

    - name: Generate config (enable ccache)
      run: |
        cd immortalwrt
        grep -q '^CONFIG_CCACHE=y' .config || echo 'CONFIG_CCACHE=y' >> .config
        make defconfig

    - name: Restore toolchain caches (per model/ref)
      if: ${{ steps.restore_repo_cache.outputs.hit != 'true' }}
      uses: actions/cache@v4
      with:
        path: |
          immortalwrt/staging_dir/toolchain-*
          immortalwrt/build_dir/toolchain-*
        key: ${{ runner.os }}-toolchain-${{ matrix.model }}-${{ env.IMMORTALWRT_REF }}
        restore-keys: |
          ${{ runner.os }}-toolchain-${{ matrix.model }}-

    - name: Restore target caches (per model/ref/seed)
      if: ${{ steps.restore_repo_cache.outputs.hit != 'true' }}
      uses: actions/cache@v4
      with:
        path: |
          immortalwrt/staging_dir/target-*
        key: ${{ runner.os }}-target-${{ matrix.model }}-${{ env.IMMORTALWRT_REF }}-${{ steps.seed.outputs.seed_hash }}
        restore-keys: |
          ${{ runner.os }}-target-${{ matrix.model }}-${{ env.IMMORTALWRT_REF }}-
          ${{ runner.os }}-target-${{ matrix.model }}-

    - name: Restore host tools cache (per ref)
      if: ${{ steps.restore_repo_cache.outputs.hit != 'true' }}
      uses: actions/cache@v4
      with:
        path: immortalwrt/build_dir/host
        key: ${{ runner.os }}-host-${{ env.IMMORTALWRT_REF }}
        restore-keys: |
          ${{ runner.os }}-host-

    - name: Compile the firmware
      id: compile
      run: |
        cd immortalwrt
        if [ "${DEBUG_BUILD}" = "true" ]; then
          JOBS=1
        else
          if [ "${JOBS_INPUT}" = "auto" ] || [ -z "${JOBS_INPUT}" ]; then
            JOBS=$(nproc)
          else
            JOBS="${JOBS_INPUT}"
          fi
        fi
        printf "%s thread compile\n" "${JOBS}"
        if [ "${DEBUG_BUILD}" = "true" ]; then VERBOSE_FLAG='V=sc'; else VERBOSE_FLAG=''; fi
        make -j"${JOBS}" ${VERBOSE_FLAG} \
          || make -j1 ${VERBOSE_FLAG} \
          || make -j1 V=s
        echo "status=success" >> $GITHUB_OUTPUT
        echo "file_date=_$(date +%Y%m%d%H%M)" >> $GITHUB_OUTPUT

    - name: Check disk space and cleanup before cache creation
      if: ${{ !cancelled() && steps.compile.outputs.status == 'success' }}
      run: |
        set -e
        echo "Disk usage before cleanup:" && df -h
        echo "Cleaning up non-reused bulky artifacts..."
        # Drop large, low-reuse build outputs (keep caches we stream)
        rm -rf immortalwrt/build_dir/target-* 2>/dev/null || true
        rm -rf immortalwrt/build_dir/hostpkg 2>/dev/null || true
        rm -rf immortalwrt/tmp 2>/dev/null || true
        rm -rf immortalwrt/bin/packages 2>/dev/null || true
        # Trim huge logs
        find immortalwrt -name "*.log" -size +100M -delete 2>/dev/null || true
        echo "Disk usage after cleanup:" && df -h

    - name: Check space usage
      if: ${{ !cancelled() }}
      run: df -hT

    - name: Collect firmware files
      id: collect
      run: |
        if [ "${{ matrix.model }}" = "tr3000" ]; then
          dir="immortalwrt/bin/targets/mediatek/filogic"
          echo "files<<EOF" >> $GITHUB_OUTPUT
          echo "$dir/immortalwrt-mediatek-filogic-cudy_tr3000-v1-ubootmod-bl31-uboot.fip" >> $GITHUB_OUTPUT
          echo "$dir/immortalwrt-mediatek-filogic-cudy_tr3000-v1-ubootmod-initramfs-recovery.itb" >> $GITHUB_OUTPUT
          echo "$dir/immortalwrt-mediatek-filogic-cudy_tr3000-v1-ubootmod-preloader.bin" >> $GITHUB_OUTPUT
          echo "$dir/immortalwrt-mediatek-filogic-cudy_tr3000-v1-ubootmod-squashfs-sysupgrade.itb" >> $GITHUB_OUTPUT
          echo "$dir/immortalwrt-mediatek-filogic-cudy_tr3000-v1-ubootmod.manifest" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
        else
          dir="immortalwrt/bin/targets/ramips/mt7621"
          echo "files<<EOF" >> $GITHUB_OUTPUT
          echo "$dir/immortalwrt-ramips-mt7621-xiaomi_mi-router-cr6606-initramfs-kernel.bin" >> $GITHUB_OUTPUT
          echo "$dir/immortalwrt-ramips-mt7621-xiaomi_mi-router-cr6606-squashfs-firmware.bin" >> $GITHUB_OUTPUT
          echo "$dir/immortalwrt-ramips-mt7621-xiaomi_mi-router-cr6606-squashfs-sysupgrade.bin" >> $GITHUB_OUTPUT
          echo "$dir/immortalwrt-ramips-mt7621-xiaomi_mi-router-cr6606.manifest" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
        fi

    - name: Upload firmware files
      uses: actions/upload-artifact@v4
      if: ${{ github.event.inputs.upload_release == 'true' && !cancelled() }}
      with:
        name: immortalwrt_firmware_${{ matrix.model }}${{ steps.compile.outputs.file_date }}
        path: ${{ steps.collect.outputs.files }}
        retention-days: 30
        compression-level: 0 # No compression for binaries/pre-compressed firmware files

    - name: Upload repo cache artifact
      if: ${{ !cancelled() && steps.compile.outputs.status == 'success' }}
      uses: actions/upload-artifact@v4
      with:
        name: repo-cache-dirs-${{ matrix.model }}-${{ (env.IMMORTALWRT_REF && env.IMMORTALWRT_REF) || 'unknown' }}-${{ steps.seed.outputs.seed_hash }}
        path: |
          immortalwrt/.ccache
          immortalwrt/dl
          immortalwrt/build_dir/host
          immortalwrt/staging_dir/host
          immortalwrt/build_dir/toolchain-*
          immortalwrt/staging_dir/toolchain-*
        if-no-files-found: ignore
        retention-days: 7
        compression-level: 0 # Mostly binaries/pre-compressed; faster uploads
        
  release:
    if: ${{ always() && needs.build.result == 'success' && github.event.inputs.upload_release == 'true' }}
    needs: build
    runs-on: ubuntu-latest
    outputs:
      release_tag: ${{ steps.tag.outputs.release_tag }}
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Prepare release files directory
        run: |
          mkdir -p release

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          path: release
          merge-multiple: true

      - name: Organize release files by model
        run: |
          mkdir -p release/tr3000 release/cr6606
          # TR3000 files
          find release -type f \( -name 'immortalwrt-mediatek-filogic-cudy_tr3000-*.fip' -o -name 'immortalwrt-mediatek-filogic-cudy_tr3000-*.itb' -o -name 'immortalwrt-mediatek-filogic-cudy_tr3000-*.bin' -o -name 'immortalwrt-mediatek-filogic-cudy_tr3000-*.manifest' \) -exec cp -f {} release/tr3000/ \;
          # CR6606 files
          find release -type f \( -name 'immortalwrt-ramips-mt7621-xiaomi_mi-router-cr6606-*.bin' -o -name 'immortalwrt-ramips-mt7621-xiaomi_mi-router-cr6606*.manifest' \) -exec cp -f {} release/cr6606/ \;

      - name: Generate release tag
        id: tag
        run: |
          VERSION_PREFIXED="immortalwrt-${IMMORTALWRT_REF:-unknown}"
          VERSION_SAFE="$(echo "$VERSION_PREFIXED" | sed 's/[^A-Za-z0-9._-]/_/g')"
          DATE_TAG="$(date +"%Y%m%d-%H%M")"
          echo "release_tag=${VERSION_SAFE}-build${GITHUB_RUN_NUMBER}-${DATE_TAG}" >> $GITHUB_OUTPUT
          echo "status=success" >> $GITHUB_OUTPUT

      - name: Summarize artifacts
        run: |
          printf "ImmortalWrt ${IMMORTALWRT_REF} firmware for\n- Cudy TR3000 (Filogic)\n- Xiaomi CR6606 (MT7621)\n" > release.md
          cat release.md >> "$GITHUB_STEP_SUMMARY"

      - name: Upload firmware to release (combined)
        uses: softprops/action-gh-release@v2
        if: steps.tag.outputs.status == 'success'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.tag.outputs.release_tag }}
          body_path: release.md
          files: |
            release/tr3000/*
            release/cr6606/*

  repo-cache-prerelease:
    if: ${{ always() && needs.build.result == 'success' }}
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: read
    strategy:
      fail-fast: false
      matrix:
        model: ${{ fromJSON((github.event.inputs.model == '' || github.event.inputs.model == 'all') && '["cr6606","tr3000"]' || format('["{0}"]', github.event.inputs.model)) }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Compute seed hash (for artifact and tag)
        id: seed
        run: |
          HASH=$(sha256sum "${{ matrix.model }}/seed.config" | cut -d ' ' -f1)
          echo "seed_hash=$HASH" >> $GITHUB_OUTPUT

      - name: Try download raw artifact zip (no extract)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -e
          set -o pipefail
          ARTIFACT_NAME="repo-cache-dirs-${{ matrix.model }}-${IMMORTALWRT_REF:-unknown}-${{ steps.seed.outputs.seed_hash }}"
          mkdir -p repo_cache
          echo "Looking for artifact: ${ARTIFACT_NAME}"
          # jq may not be present on ubuntu-latest minimal image
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y >/dev/null 2>&1 || true
            sudo apt-get install -y jq >/dev/null 2>&1 || true
          fi
          API_URL="https://api.github.com/repos/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}/artifacts?per_page=100"
          RESP=$(curl -fsSL -H "Authorization: Bearer ${GITHUB_TOKEN}" -H "Accept: application/vnd.github+json" "${API_URL}" || true)
          if [ -n "${RESP}" ] && echo "${RESP}" | jq -e .artifacts >/dev/null 2>&1; then
            ART_ID=$(echo "${RESP}" | jq -r --arg n "${ARTIFACT_NAME}" '.artifacts[] | select(.name==$n) | .id' | head -n1)
            if [ -n "${ART_ID}" ] && [ "${ART_ID}" != "null" ]; then
              echo "Found artifact id: ${ART_ID}. Downloading zip..."
              curl -fsSL -H "Authorization: Bearer ${GITHUB_TOKEN}" -L -o repo_cache/repo-cache.zip "https://api.github.com/repos/${GITHUB_REPOSITORY}/actions/artifacts/${ART_ID}/zip"
              if [ -s repo_cache/repo-cache.zip ]; then
                echo "ASSET_NAME=repo-cache.zip" >> $GITHUB_ENV
                echo "ASSET_PATH=repo_cache/repo-cache.zip" >> $GITHUB_ENV
                echo "CONTENT_TYPE=application/zip" >> $GITHUB_ENV
                echo "ZIP_READY=true" >> $GITHUB_ENV
              fi
            fi
          fi

      # Skipping directory download/extraction; forward the downloaded artifact zip directly

      - name: Create prerelease and upload repo cache asset
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -e
          set -o pipefail
          CACHE_TAG="cache-${{ matrix.model }}-${IMMORTALWRT_REF:-unknown}-${{ steps.seed.outputs.seed_hash }}"
          CACHE_NAME="${ASSET_NAME:-repo-cache.zip}"
          CACHE_PATH="${ASSET_PATH:-repo_cache/repo-cache.zip}"
          CONTENT_TYPE_HEADER="${CONTENT_TYPE:-application/zip}"
          API_BASE="https://api.github.com"
          echo "Ensuring release '${CACHE_TAG}' exists..."
          if ! curl -fsSL -H "Authorization: Bearer ${GITHUB_TOKEN}" -H "Accept: application/vnd.github+json" "${API_BASE}/repos/${GITHUB_REPOSITORY}/releases/tags/${CACHE_TAG}" -o release.json 2>/dev/null; then
            PAYLOAD=$(printf '{"tag_name":"%s","name":"%s","prerelease":true,"make_latest":"false"}' "${CACHE_TAG}" "${CACHE_TAG}")
            curl -fsSL -X POST -H "Authorization: Bearer ${GITHUB_TOKEN}" -H "Accept: application/vnd.github+json" -d "${PAYLOAD}" "${API_BASE}/repos/${GITHUB_REPOSITORY}/releases" -o release.json
          fi
          UPLOAD_URL=$(sed -n 's/.*"upload_url"[ ]*:[ ]*"\([^"]*\)".*/\1/p' release.json | head -n1)
          UPLOAD_URL="${UPLOAD_URL%\{*}"
          echo "Uploading ${CACHE_NAME} to ${UPLOAD_URL}?name=${CACHE_NAME}"
          curl -fsSL -X POST \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -H "Content-Type: ${CONTENT_TYPE_HEADER}" \
            --data-binary @"${CACHE_PATH}" \
            "${UPLOAD_URL}?name=${CACHE_NAME}" \
            || echo "Repo cache upload failed or asset already exists; continuing."

          # Also attempt to upload/update a generic cache for broader reuse (best-effort)
          GENERIC_TAG="cache-${{ matrix.model }}-${IMMORTALWRT_REF:-unknown}"
          echo "Ensuring generic release '${GENERIC_TAG}' exists..."
          if ! curl -fsSL -H "Authorization: Bearer ${GITHUB_TOKEN}" -H "Accept: application/vnd.github+json" "${API_BASE}/repos/${GITHUB_REPOSITORY}/releases/tags/${GENERIC_TAG}" -o generic_release.json 2>/dev/null; then
            PAYLOAD=$(printf '{"tag_name":"%s","name":"%s","prerelease":true,"make_latest":"false"}' "${GENERIC_TAG}" "${GENERIC_TAG}")
            curl -fsSL -X POST -H "Authorization: Bearer ${GITHUB_TOKEN}" -H "Accept: application/vnd.github+json" -d "${PAYLOAD}" "${API_BASE}/repos/${GITHUB_REPOSITORY}/releases" -o generic_release.json || true
          fi
          UPLOAD_URL_GEN=$(sed -n 's/.*"upload_url"[ ]*:[ ]*"\([^"]*\)".*/\1/p' generic_release.json | head -n1)
          UPLOAD_URL_GEN="${UPLOAD_URL_GEN%\{*}"
          echo "Uploading generic cache ${CACHE_NAME} to ${UPLOAD_URL_GEN}?name=${CACHE_NAME} (best-effort)"
          curl -fsSL -X POST \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -H "Content-Type: ${CONTENT_TYPE_HEADER}" \
            --data-binary @"${CACHE_PATH}" \
            "${UPLOAD_URL_GEN}?name=${CACHE_NAME}" || echo "Generic cache upload skipped/failed; continuing."

  notify-completion:
    runs-on: ubuntu-latest
    needs: [ build, release ]
    if: always()
    timeout-minutes: 5
    steps:
      - name: Notify via Bark
        if: always()
        uses: harryzcy/action-bark@v2.3.0
        with:
          status: ${{ env.UPLOAD_RELEASE == 'true' && needs.release.result || needs.build.result }}
          on_status: success, failure, cancelled
          title: "${{ ((env.UPLOAD_RELEASE == 'true' && needs.release.result == 'success') || (env.UPLOAD_RELEASE != 'true' && needs.build.result == 'success')) && format('ðŸš€ImmortalWrtðŸš€: Success (Run #{0})', github.run_number) || format('ðŸ’¥ImmortalWrtðŸ’¥: Failed (Run #{0})', github.run_number) }}"
          body: "${{ ((env.UPLOAD_RELEASE == 'true' && needs.release.result == 'success') || (env.UPLOAD_RELEASE != 'true' && needs.build.result == 'success')) && ( env.UPLOAD_RELEASE == 'true' && format('Run #{0}: âœ… release published (tag: {1}).', github.run_number, needs.release.outputs.release_tag) || ( github.event_name == 'workflow_dispatch' && github.event.inputs.model != '' && github.event.inputs.model != 'all' && format('Run #{0}: âœ… firmware for {1} built successfully.', github.run_number, github.event.inputs.model) || format('Run #{0}: âœ… firmware built successfully.', github.run_number) ) ) || format('Run #{0}: ðŸ’¥ Build failed: build={1}, release={2}', github.run_number, needs.build.result, needs.release.result) }}"
          bark_server_url: ${{ secrets.BARK_SERVER_URL }}
          device_key: ${{ secrets.BARK_DEVICE_KEY }}
          level: active
          sound: ${{ ((env.UPLOAD_RELEASE == 'true' && needs.release.result == 'success') || (env.UPLOAD_RELEASE != 'true' && needs.build.result == 'success')) && env.BARK_SUCCESS_SOUND || env.BARK_FAILURE_SOUND }}
          icon: ${{ env.BARK_ICON }}
          group: ${{ env.BARK_GROUP }}
